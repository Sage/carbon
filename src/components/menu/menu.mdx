import { Meta, ArgTypes, Canvas } from "@storybook/blocks";
import TranslationKeysTable from "../../../.storybook/utils/translation-keys-table";

import * as ScrollableBlockStories from "./scrollable-block/scrollable-block.stories";
import * as MenuSegmentTitleStories from "./menu-segment-title/menu-segment-title.stories";
import * as MenuFullscreenStories from "./menu-full-screen/menu-full-screen.stories";
import * as MenuDividerStories from "./menu-divider/menu-divider.stories";
import * as MenuItemStories from "./menu-item/menu-item.stories";
import * as MenuStories from "./menu.stories";

<Meta of={MenuStories} />

# Menu

<a
  target="_blank"
  href="https://zeroheight.com/2ccf2b601/p/59e0bd-menu"
  style={{ color: "#007E45", fontWeight: "bold", textDecoration: "underline" }}
  rel="noreferrer"
>
  Product Design System component
</a>

Provides navigation for an app, which can be used via mouse or keyboard.

## Contents

- [Quick Start](#quick-start)
- [Examples](#examples)
- [Props](#props)
- [Translation keys](#translation-keys)

## Quick Start

```javascript
import {
  Menu,
  MenuItem,
  MenuDivider,
  MenuSegmentTitle,
  ScrollableBlock,
  MenuFullscreen,
} from "carbon-react/lib/components/menu";
```

## Examples

### Default

<Canvas of={MenuStories.DefaultStory} />

> **Note**: To ensure a `MenuItem` is interactive, it should either have an `href`, `onClick` or `submenu` prop, or contain another focusable Carbon component like Button. Without one of these, the item will not be keyboard-focusable or interactive, affecting accessibility for keyboard and screen reader users.

### Selected

<Canvas of={MenuStories.SelectedStory} />

### Divider

<Canvas of={MenuStories.DividerStory} />

### Large divider

<Canvas of={MenuStories.LargeDividerStory} />

### Segment title

<Canvas of={MenuStories.SegmentTitleStory} />

### With alternate colour variant

<Canvas of={MenuStories.AlternateColourStory} />

### Submenu Nodes

The `submenu` prop on `MenuItem` accepts a node, which allows the creation of complex composition for the title with **non-interactive elements only**, when the `MenuItem` has a submenu. It is recommended to also pass the 
`ariaLabel` prop when the composition is especially complex, to ensure screen readers can provide the correct context to users.

<Canvas of={MenuStories.SubmenuNodes} />

> **Note**: Also, if a complex composition is used, proceed with caution when using the `maxWidth` prop, the onus is now on the consumer to ensure the content of the `submenu` is properly communicated to users. 


### Submenu options

<Canvas of={MenuStories.SubmenuOptionsStory} />

### Submenu direction left

<Canvas of={MenuStories.SubmenuDirectionLeftStory} />

### With icon

<Canvas of={MenuStories.WithIconStory} />

### No dropdown arrow on submenu

The example below has set the `showDropdownArrow` to false for the MenuItem with a submenu which means no dropdown arrow
is rendered.

<Canvas of={MenuStories.NoDropdownArrowOnSubmenuStory} />

### Split submenu into separate component

If you need to split out a submenu into a separate component, it must be done as shown below in order for the keyboard navigation to work as intended.

<Canvas of={MenuStories.SplitSubmenuIntoSeparateComponentStory} />

### Submenu icon and text alignment

In order to align text and icons within a submenu a `Box` component will need to be used to adjust the margin of the content.

<Canvas of={MenuStories.SubmenuIconAndTextAlignment} />

### Scrollable submenu

A scrollable submenu can be added using the `ScrollableBlock` component. This can be used for all of the submenu items, or just a selection, as shown in `Menu Item Four` below.
Note that only one `ScrollableBlock` can be used within a single submenu.

<Canvas of={MenuStories.ScrollableSubmenuStory} />

### Scrollable submenu with parent

This is an example of using the `parent` prop of `ScrollableBlock` to render a scrollable sublist of a parent item. The `parentVariant`
prop can be used to give it a variant that's different from that used in the `ScrollableBlock`.

Note that the result shown here, for those interacting with the page without assistive technology, is the same as that which
would be produced by leaving out the `parent` prop and putting the `Search` component inside a separate `MenuItem` just before the
`ScrollableBlock`. However the rendered HTML would be different, with the `ScrollableBlock` becoming a sublist inside its own list
item that is not connected to the Search - in this example there is a clear semantic relationship between the search input and the
scrollable list so the `parent` prop should be used to ensure screen readers make the relationship clear to their users.

<Canvas of={MenuStories.ScrollableSubmenuWithParent} />

### Submenu with search

<Canvas of={MenuStories.SubmenuWithSearch} />

### Truncated titles

Menu items can be given a maximum width using the `maxWidth` prop. Text overflowing this width will be truncated.
A title attribute is added to the item when using this prop, containing the full menu item text.

<Canvas of={MenuStories.TruncatedTitlesStory} />

### Controlling the submenu width

By default, the submenu will have the same width as the widest `MenuItem`. This can be changed
by setting the `submenuMaxWidth` or `submenuMinWidth` prop on the submenu's parent `MenuItem` component.

Setting `submenuMaxWidth` will override the `maxWidth` prop of any `MenuItem` in the submenu. Overflowing submenu items will wrap instead of truncating.

<Canvas of={MenuStories.ControllingTheSubmenuWidth} />

### Responsive composition

This story is best viewed in the `canvas` view and by adjusting the size of the window to see the various Menu compositions
at the different breakpoints.

<Canvas of={MenuStories.ResponsiveCompositionStory} />

### Fullscreen view

This story is best viewed in the `canvas` view and by adjusting the size of the window. The fullscreen menu behaviour will
trigger when the screen size is smaller than `1200px`. Please note the `MenuItem`s are intended to have a width that fills the viewport,
as such any `maxWidth` value passed will not be set when they are children of `MenuFullscreen`.

The call-to-action `MenuItem` should always be focused when the `MenuFullscreen` is closed. However, in some instances it may not receive focus
due to specific browser design choices.

<Canvas of={MenuStories.FullscreenViewStory} />

### Full-screen Menu with segment styling

When using the `alternate` variant for a `MenuItem` that is a child of a `MenuSegmentTitle`, the menu item  will automatically
update its styling to match the segment title. Note that this only applies to the `MenuItem` instances within a normal `Menu` component;
when found within a `MenuFullscreen` component, the `alternate` variant will not be styled differently.

This story is best viewed in the `canvas` view.

<Canvas of={MenuStories.MenuFullscreenWithSegmentStyling} />

## Props

### Menu

<ArgTypes of={MenuStories} />

### MenuItem

<ArgTypes of={MenuItemStories} />

### ScrollableBlock

<ArgTypes of={ScrollableBlockStories} />

### MenuDivider

<ArgTypes of={MenuDividerStories} />

### MenuSegmentTitle

<ArgTypes of={MenuSegmentTitleStories} />

### MenuFullscreen

<ArgTypes of={MenuFullscreenStories} />

## Translation keys

The following keys are available to override the translations for this component by passing in a custom locale object
to the [i18nProvider](../?path=/docs/documentation-i18n--docs).

<TranslationKeysTable
  translationData={[
    {
      name: "menuFullscreen.ariaLabels.closeButton",
      description: "Aria label for the MenuFullscreen's close button",
      type: "func",
      returnType: "string",
    },
  ]}
/>
