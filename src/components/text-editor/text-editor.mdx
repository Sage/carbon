import { Meta, ArgTypes, Canvas } from "@storybook/blocks";

import * as TextEditorStories from "./text-editor.stories";
import TranslationKeysTable from "../../../.storybook/utils/translation-keys-table";

<Meta of={TextEditorStories} />

# Text Editor

<a
  target="_blank"
  href="https://zeroheight.com/2ccf2b601/p/827c18-text-editor"
  style={{ color: "#007E45", fontWeight: "bold", textDecoration: "underline" }}
  rel="noreferrer"
>
  Product Design System component
</a>

Provides an interactive Text Editor that allows users to format text with various styles and save the content as JSON or HTML. For further documentation on this component, please read [our documentation regarding Lexical](../?path=/docs/documentation-using-lexical--docs)

## Contents

- [Quick Start](#quick-start)
- [Interactive Demo](#interactive-demo)
- [Advanced Usage](#advanced-usage)
- [Validation States](#validation-states)
- [Props](#props)
- [Translation Keys](#translation-keys)

## Quick Start

```javascript
import TextEditor, {
  createEmpty,
  createFromHTML,
} from "carbon-react/lib/components/text-editor";
```

To use the Text Editor, import the `TextEditor` component. Use `createFromHTML` to convert HTML content for the editor, or `createEmpty` for an empty initial state.

## Interactive Demo

Use the [Demo](../?path=/story/text-editor--demo) story with controls to explore basic props, callbacks, and validation states.

## Advanced Usage

### Focusing the Text Editor Programmatically

```javascript
import { TextEditorHandle } from "carbon-react/lib/components/text-editor";
```

The `TextEditorHandle` type provides an imperative handle for programmatic control over the Text Editor.
Using a `ref`, you can access its `focus()` method to set focus on the Text Editor as needed.

<Canvas of={TextEditorStories.ProgrammaticFocus} />

### Toolbar controls

The `toolbarControls` prop allows you to customize which controls are displayed in the toolbar. It accepts an array of strings, each representing a control to be included. The available controls are:

- `typography`
- `bold`
- `italic`
- `underline`
- `unordered-list`
- `ordered-list`
- `link`

By default, all controls are included, but you can provide any combination of them to tailor the toolbar to your specific needs.

<Canvas of={TextEditorStories.ToolbarControls} />

### With Header and Footer

The Text Editor accepts `header` and `footer` properties that can contain any valid React node, rendered above the toolbar and below the editor respectively to provide space for custom elements like titles, controls, or contextual information.

<Canvas of={TextEditorStories.HeaderAndFooter} />

### onChange Handler

Providing an `onChange` callback allows for accessing any content updates within the editor. The function will be called whenever text content is modified or styled.

#### Parameters

- `value`: The updated text content as a string.
- `formattedValues`: An object containing two properties that represent the editor's content in a serialised format. This can be used to save the content to an external store like a database or local storage.
  - `htmlString`: A HTML representation of the editor content, as a string.
  - `json`: The JSON representation of the editor content, as a string.

> **Note**: `TextEditor` is an uncontrolled component. See [Externally overwriting the editor's content](#externally-overwriting-the-editors-content) for details on updating content after initialization.

<Canvas of={TextEditorStories.OnChange} />

### Externally overwriting the editor's content

**`TextEditor` is an uncontrolled component**. It manages its own underlying state for performance reasons, since it manages a virtual DOM representation of the editor content, which is expensive to update frequently. However, there are times when you may need to externally overwrite the editor's content, for example, when resetting a form or updating the content based on external data from a server or local storage.

Updating the component's `key` will force React to re-create it, which will reset the editor's content to a new `initialValue` provided.

> **Caution**: Be wary about overwriting the editor's content too frequently. As resetting the component's key re-creates it from scratch each time, so doing this regularly could lead to a poor user experience. The editor is designed to handle its own state efficiently, so external updates should be used sparingly.

<Canvas of={TextEditorStories.ExternallyOverwriting} />

### onSave Handler

To handle the content of the editor when the `Save` button is clicked, you can set the `onSave` property to a function. The callback function
returns two values: the JSON and HTML content of the editor. The value of `json` reflects the structure that the editor understands/uses
internally; the value of `htmlString` is the raw content of the editor in HTML format (note that the HTML returned is not complete HTML - only
the content of the editor is converted).

If the `onSave` property is not provided, the `Save` button will not be displayed.

Type into the editor and the click the **Show Data Formats** button in the example below to see the JSON and HTML content of the editor.

<Canvas of={TextEditorStories.OnSave} />

### Setting Initial Values

You can set the editor's initial value using either HTML or JSON format. For HTML content, use the `createFromHTML` function to convert it to the editor's expected format, then pass the result to the `initialValue` property. For JSON content, pass the object directly to `initialValue` using the same format returned by the `onSave` callback.

<Canvas of={TextEditorStories.SettingInitialValues} />

### Link Support

The editor supports adding links by typing URLs directly or selecting text and pasting a URL to wrap it as a link. Links open in new tabs when clicked.

<Canvas of={TextEditorStories.Links} />

There may be times when you want to perform an action when a link is added to the editor. You can use the `onLinkAdded` callback to obtain a
string representation of the link that was added, updated or removed. The function will be called whenever a link is added to the editor.
In the example below, the most recently-added link will be displayed in the `Link` section below the editor; adding a new link will replace
the previous one.

Note that this usage is for demonstration purposes only; you should maintain the list of URLs added to the editor in your application state.

<Canvas of={TextEditorStories.WithLinkAddedCallback} />

### With Link Previews

The `previews` property accepts an array of React JSX elements to render link previews below the editor. You can use simple anchor elements, custom preview components, or mix different styles as needed.

<Canvas of={TextEditorStories.WithLinkPreviews} />

### Translations

You can override the default translations for the Text Editor by passing a custom locale object to the `i18nProvider`. Consult the [translation keys](#translation-keys) section for a list of available keys.

<Canvas of={TextEditorStories.Translations} />

### Read-Only Mode

You can specify that the editor should be read-only by setting the `readOnly` property to `true`. In read-only mode, the editor will not allow any changes to be made to the content.

<Canvas of={TextEditorStories.ReadOnly} />

### Multiple Editors

You can render multiple instances of the Text Editor on the same page. Each editor should have a unique `namespace` property, which is used to identify
the editor when monitoring for formatting changes, accessible navigation, etc.

<Canvas of={TextEditorStories.MultipleEditors} />

### With Custom Plugins

The `customPlugins` prop allows consumers of the `TextEditor` component to inject one or more custom [Lexical](https://lexical.dev/) plugins. This provides flexibility to extend the editor with features like mentions, emoji pickers, custom toolbars, and more â€” without modifying the core editor. This prop is optional and supports a single plugin, multiple plugins (via fragments or arrays), or `null`.

#### Example: Creating and Using a Custom Plugin

```tsx
// CustomWordCountPlugin.tsx
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { useEffect } from "react";
import { $getRoot } from "lexical";

const CustomWordCountPlugin = () => {
  // Get the Lexical editor instance from context
  const [editor] = useLexicalComposerContext();
  // Local state to store the current word count
  const [wordCount, setWordCount] = useState(0);
  useEffect(() => {
    // Register a listener to run every time the editor updates
    return editor.registerUpdateListener(({ editorState }) => {
      // Read the editor state in a read-only context
      editorState.read(() => {
        // Get the full text content from the root of the editor
        const text = $getRoot().getTextContent();
        // Split the text by whitespace and count non-empty words
        const count = text.trim().split(/\s+/).filter(Boolean).length;
        // Update local word count state
        setWordCount(count);
      });
    });
  }, [editor]); // Only run this effect once per editor instance
  // Render the word count UI with styled container
  return (
    <Typography ml={1} mb={0}>
      Word Count: {wordCount}
    </Typography>
  );
};
```

```tsx
// Using it with TextEditor
import TextEditor from "./TextEditor";
import { CustomWordCountPlugin } from "./CustomWordCountPlugin";

const App = () => (
  <TextEditor
    labelText="Text Editor"
    customPlugins={<CustomWordCountPlugin />}
  />
);
```

<Canvas of={TextEditorStories.WithCustomPlugins} />

### Mentions

The Text Editor supports mentions, and offers a built-in `Mentions` component to facilitate this. The `Mentions` component provides an interface for displaying a list of mentionable items and handling user interactions.

To use the `Mentions` component, you need to provide it with a list of items that can be mentioned. Each item should be a `Mention` instance and have an `id` and a `name`.

```tsx
import TextEditor, {
  MentionsPlugin,
  Mention,
} from "carbon-react/lib/components/text-editor";

const mentionsData: Mention[] = [
  {
    id: "1",
    name: "Amanda Ball",
  },
  {
    id: "2",
    name: "Anaya Underwood",
    initials: "AU",
  },
  {
    id: "3",
    name: "Alastair Cox",
    initials: "AC",
  },
  {
    id: "4",
    name: "Anwar al-Awlaki",
    src: "https://loremfaces.net/24/id/2.jpg",
  },
  {
    id: "5",
    name: "Angela Alabaster",
    src: "https://loremfaces.net/24/id/1.jpg",
  },
  {
    id: "6",
    name: "Alfred Jones",
    iconType: "accessibility_web",
  },
];
```

Import the `Mentions` component and include it in the `customPlugins` prop of the `TextEditor`. You also need to provide an array of `Mention` items that can be queried (this will happen internal to the plugin).

Queries are triggered by typing the `@` character followed by text. The plugin will filter the provided items based on the query and display a list of matching items.

Mentions accept the following properties. If none of `initials`, `src` and `iconType` are provided, then a default icon will be displayed:

| Property | Purpose                                                         |
| -------- | --------------------------------------------------------------- |
| id       | The ID of the Mention entry                                     |
| name     | The name shown in the list                                      |
| initials | The initials to be shown in the Mention's avatar                |
| iconType | The icon to be used in the Mention's avatar                     |
| src      | The source URL of the image to be shown in the Mention's avatar |

<Canvas of={TextEditorStories.Mentions} />

## Validation States

This component supports input validation, see our [Validations](../?path=/docs/documentation-validations--docs) documentation page for more information.

## Props

### Text Editor

<ArgTypes of={TextEditorStories} />

## Translation Keys

The following keys are available to override the translations for this component by passing in a custom locale object to the
[i18nProvider](../?path=/docs/documentation-i18n--docs).

<TranslationKeysTable
  translationData={[
    {
      name: "TextEditor.boldAria",
      description:
        "The text to be read out by screen readers when the Bold formatting button is focused.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.cancelButton",
      description: "The text to show on the Cancel button.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.cancelButtonAria",
      description:
        "The text to be read out by screen readers when the Cancel button is focused.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.characterCounter",
      description:
        "The text to display on the character counter. The function should accept a single argument, the number of characters remaining.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.characterLimit",
      description:
        "The text to display when the character limit has been exceeded. The function should accept a single argument, the number of characters over the limit.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.contentEditorAria",
      description:
        "The text to be read out by screen readers when the Content Editor is focused.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.italicAria",
      description:
        "The text to be read out by screen readers when the Italic formatting button is focused.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.orderedListAria",
      description:
        "The text to be read out by screen readers when the Ordered List formatting button is focused.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.saveButton",
      description: "The text to show on the Save button.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.saveButtonAria",
      description:
        "The text to be read out by screen readers when the Save button is focused.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.toolbarAriaLabel",
      description:
        "The text to be read out by screen readers for the toolbar aria-label attribute.",
      type: "func",
      returnType: "string",
    },
    {
      name: "TextEditor.unorderedListAria",
      description:
        "The text to be read out by screen readers when the Unordered List formatting button is focused.",
      type: "func",
      returnType: "string",
    },
  ]}
/>
